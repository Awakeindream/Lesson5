# EASY
# Задача-1:
# Напишите скрипт, создающий директории dir_1 - dir_9 в папке,
# из которой запущен данный скрипт.
# И второй скрипт, удаляющий эти папки.
import os

for i in range(1,10):
    dir = 'dir_{}'.format(i)
    os.mkdir(dir)
for i in range(1,10):
    dir = 'dir_{}'.format(i)
    os.rmdir(dir)

# Задача-2:
# Напишите скрипт, отображающий папки текущей директории.
import os

print(os.listdir(path="."))

# Задача-3:
# Напишите скрипт, создающий копию файла, из которого запущен данный скрипт.
#
# Option1

infile = open('learning_python.py', 'w', encoding='utf-8')
infile.close()
infile = open('learning_python.py', 'r', encoding='utf-8')
text = infile.read()
infile.close()
outfile = open('learning python_copy.py', 'w', encoding='utf-8')
outfile.write(text)
outfile.close()

# option2
import os
import sys
import shutil

def copy_file():
     """
     Функция для копирования текущего файла
     """
     file_name = sys.argv[0]  # Возвращает список аргументов из командной строки. Нулевой аргумент по умолчанию
     # всегда равен пути к скрипту в котором присутствует данный метод. Если при запуске скрипта с командной строки
     # мы укажем там же через пробел ещё какие-то другие символы, то они и будут нашими первыми, вторыми,
     # третьими и т.д.
     # аргументами из командной строки в нашем списке.
     new_file_name = file_name.split('.py').pop(0) + '_copy.py'  # метод split превращает строку в список, где '.py'
     # является разделителем. Метод pop удаляет елемент под индексом из списка и возвращает
     # этот элемент в наше выражение.
     cur_file = os.path.join(os.getcwd(), sys.argv[0])  # os.path.join(path1, path3, ...) - соединяет пути
     # с учётом особенностей операционной системы. os.getcwd() - текущая рабочая папка.
     new_file = os.path.join(os.getcwd(), new_file_name)
     try:
         shutil.copy(cur_file, new_file)  # shutil.copy(src, dst, follow_symlinks=True) - копирует содержимое
         # файла src в файл или папку dst. Если dst является директорией, файл будет скопирован с тем же
         # названием, что было в src. Функция возвращает путь к местонахождению нового скопированного файла.
         # Модуль shutil содержит набор функций высокого уровня для обработки файлов, групп файлов, и папок.
         # В частности, доступные здесь функции позволяют копировать, перемещать и удалять файлы и папки.
         # Часто используется вместе с модулем os.
     except:
         print("Ошибка!")


 copy_file()


# NORMAL
# Задача-1:
# Напишите небольшую консольную утилиту,
# позволяющую работать с папками текущей директории.
# Утилита должна иметь меню выбора действия, в котором будут пункты:
# 1. Перейти в папку
# 2. Просмотреть содержимое текущей папки
# 3. Удалить папку
# 4. Создать папку
# При выборе пунктов 1, 3, 4 программа запрашивает название папки
# и выводит результат действия: "Успешно создано/удалено/перешел",
# "Невозможно создать/удалить/перейти"
# Для решения данной задачи используйте алгоритмы из задания easy,
# оформленные в виде соответствующих функций,
# и импортированные в данный файл из easy.py
# Главный файл
 
import control_files


print('Программа позволяет управлять файлами. При введении команд:\n \
       5 - Посмотреть папки и файлы в текущей директории\n \
       1 - Создать новую директорию\n \
       2 - удалить директорию\n \
       3 - Перейти в указанную папку\n \
       4 - Подняться в папку на уровень выше\n \
       0 - Выйти из программы\n')  # символ \ преносит наше выражение на другую строку так как код очень длинный.
#  \n - символ вертикальной табуляции.
       action = 10
while action != 0:
     action = int(input('Введите номер действия, которое хотите сделать: '))
     if action == 5:
         print('Папки и файлы в текущей директории: ')
         control_files.dir_contain()
     elif action == 1:
         name = input('Введите имя папки, которую хотите создать: ')
         control_files.make_dir(name)
     elif action == 2:
         name = input('Введите имя папки, которую хотите удалить: ')
         control_files.del_dir(name)
     elif action == 3:
         name = input('Введите имя папки, в которую хотите перейти: ')
         control_files.change_dir(name)
     elif action == 4:
         print('Подняться в папку на уровень выше')
         control_files.up_dir()
     else:
         print('Ввели что-то не то!')

 Модуль control_files.py По заданию он дожен быть отдельным файлом
 import os


def change_dir(name):  # перейти в папку "путь", путь указывается с корневого каталога
     try:
         os.chdir(name)  # os.chdir(path) - смена текущей директории.
         print('Успешно! Текущая папка {} содержит: {}'.format(name, os.listdir()))
     except Exception:  # Не надо перехватывать все! Это сокрытие ошибок!
         print('Невозможно перейти в папку. Проверяй код, какая-то ошибка')


def up_dir(): # подняться в папку на уровень выше
     change_dir('..')  # ".." означает - "РОДИТЕЛЬ"


def dir_contain():
     print(os.listdir())  # os.listdir(path=".") - список файлов и директорий в папке.


def make_dir(name):
     if not name:
         print("Необходимо указать имя директории параметром")
         return
     try:
         os.mkdir(name)  # os.mkdir(path, mode=0o777, *, dir_fd=None) - создаёт директорию.
         print('Успешно! Папка {} создана, проверяйте: {}'.format(name, os.listdir()))
     except Exception:
         print("Не получатся создать папку. Проверяй код, какая-то ошибка")


 def del_dir(name):
     try:
         os.rmdir(name)  # os.rmdir(path, *, dir_fd=None) - удаляет пустую директорию.
         print('Успешно! Папка {} удалена, проверяйте: {}'.format(name, os.listdir()))
     except Exception:
         print("Невозможно удалить папку. Проверяй код, какая-то ошибка")


# HARD Задание-1:
# Доработайте реализацию программы из примера examples/5_with_args.py, данную программу можно найти в методичке в
# описании модуля sys, либо рядом с файлом домашнего задания.
# добавив реализацию следующих команд (переданных в качестве аргументов):
# cp <file_name> - создает копию указанного файла
# rm <file_name> - удаляет указанный файл (запросить подтверждение операции)
# ls - отображение полного пути текущей директории
# путь считать абсолютным (full_path) -
# в Linux начинается с /, в Windows с имени диска,
# все остальные пути считать относительными.
# Важно! Все операции должны выполняться в той директории, в который вы находитесь.
# Исходной директорией считать ту, в которой был запущен скрипт.
# P.S.  По возможности, сделайте кросс-платформенную реализацию.
# python Домашнее задание №5.py param1(ключ) param2(имя дирректории) param3(имя файла)
import os
import sys


print('sys.argv = ', sys.argv)  # sys.argv - список аргументов командной строки, передаваемых сценарию Python.
#   sys.argv[0] является именем скрипта (пустой строкой в интерактивной оболочке).


def print_help():
     print("help - получение справки")
     print("mkdir <dir_name> - создание директории")
     print("ping - тестовый ключ")
     print("cp <file_name> - создает копию указанного файла")
     print("rm <file_name> - удаляет указанный файл")
     print("ls - отображение полного пути текущей директории")


def make_dir():
     if not dir_name:
         print("Необходимо указать имя директории вторым параметром")
         return  # return здесь нужен, всё что ниже не выполняется если программа доходит до него.
     dir_path = os.path.join(os.getcwd(), dir_name)
     # os.path.join(path1[, path2[, ...]]) - соединяет пути с учётом особенностей операционной системы.
     # os.getcwd() - текущая рабочая директория.
     try:
         os.mkdir(dir_path)
         # os.mkdir(path, mode=0o777, *, dir_fd=None) - создаёт директорию. OSError, если директория существует.
         print('диектория {} создана'.format(dir_name))
     except FileExistsError:
         print('директория {} уже существует'.format(dir_name))


 def ping():
     print("pong")


def cp():
     if not file_name:
         print("Необходимо указать имя файла третьим параметром")
         return  # return здесь нужен, всё что ниже не выполняется если программа доходит до него.
     file_path = os.path.join(os.getcwd(), file_name)
     # os.path.join(path1[, path2[, ...]]) - соединяет пути с учётом особенностей операционной системы.
     # os.getcwd() - текущая рабочая директория.
     try:
         infile = open(file_path, 'r', encoding='utf-8')
         text = infile.read()
         file_name_copy = "copy_" + file_name
         outfile = open(file_name_copy, 'w', encoding='utf-8')
         outfile.write(text)
         infile.close()
         outfile.close()
     except FileExistsError:
         print('Файл {} не существует'.format(file_name))


def rm():
     if not file_name:
         print("Необходимо указать имя файла третьим параметром")
         return  # return здесь нужен, всё что ниже не выполняется если программа доходит до него.
     file_path = os.path.join(os.getcwd(), file_name)
     # os.path.join(path1[, path2[, ...]]) - соединяет пути с учётом особенностей операционной системы.
     # os.getcwd() - текущая рабочая директория.
     try:
         os.remove(file_path)
         # os.remove(path, *, dir_fd=None) - удаляет путь к файлу.
         print('Файл {} удален'.format(file_name))
         print('Убедитесь, что теперь в текущей директории нет этого файла: {}'.format(
             os.getcwd()))  # Подтверждение операции
     except FileExistsError:
         print('Файл {} не существует'.format(file_name))


def ls():
     print(os.getcwd())
     # os.getcwd() - текущая рабочая директория.


 # Создаем словарик
do = {
     "help": print_help,
     "mkdir": make_dir,
     "ping": ping,
     "cp": cp,
     "rm": rm,
     "ls": ls,
 }

# присваиваем параметры командной строки заданным переменным.
 try:
     file_name = sys.argv[3]
     # sys.argv - список аргументов командной строки, передаваемых сценарию Python.
     # sys.argv[0] является именем скрипта (пустой строкой в интерактивной оболочке).
 except IndexError:
     file_name = None
 try:
     dir_name = sys.argv[2]
 except IndexError:
     dir_name = None
 try:
     key = sys.argv[1]
 except IndexError:
     key = None
     # ключ - это функция ping, но можно создать свой.


 if key:
     # если есть ключ, то выполняется блок кода дальше.
     if do.get(key):
         # если параметр ключ есть в словаре, то выполняется блок кода дальше
         # dict.get(key[, default]) - возвращает значение ключа, но если его нет,
         # не бросает исключение, а возвращает default (по умолчанию None).
         do[key]()
         # В зависимости от ключа будет исполняться та или иная функция.
         # do[help] == print_help, do[help]() == print_help()
     else:
         print("Задан неверный ключ")
         print("Укажите ключ help для получения справки")


